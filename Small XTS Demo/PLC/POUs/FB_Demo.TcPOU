<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Demo" Id="{885b8ba9-974c-4397-956d-318c5f707ab4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Demo
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
 	CAGroup             : AXES_GROUP_REF;	
	Master : AXIS_REF;
	Mover1 : AXIS_REF;
	Mover2 : AXIS_REF;
	{attribute 'hide'} 
	SelectedAxis	: REFERENCE TO AXIS_REF;
	{attribute 'hide'} 
	NullAxis		:AXIS_REF;
	
	//Logic vars
	Step  : E_Step;
	Cycle : UINT;

	//User input
	Mode                  : E_Mode;
	Start                 : BOOL;
	StartPremisive AT %Q* : BOOL;
	Stop                  : BOOL;
	StopPremisive AT %Q*  : BOOL;
	Reset                 : BOOL;
	ResetPremisive AT %Q* : BOOL;

	UsbPbStart AT %I* : BOOL;
	UsbPbStop  AT %I* : BOOL;
	UsbPbReset AT %I* : BOOL;

	rtStart : R_TRIG;
	rtStop  : R_TRIG;
	rtReset : R_TRIG;

	VelocityCycle : ARRAY[0..3] OF LREAL := [1250.0, 1000.0, 750.0, 500.0];

	NumTouches			:UDINT;
	DebounceTouch		:TON:=(PT:=T#100MS);
	SingleFingerXPos	:LREAL;
	

	NumberOfMoversSelected : UDINT;
	SelectedMovers         : tchmi_framework_definitions_XtsMoverList;

	//Power
	AllAxisEnabled       : BOOL;
	AllAxisDisabled      : BOOL;
	OneOrMoreAxisInError : BOOL;
	MasterPower          : MC_Power;
	MasterHault          : MC_Halt;
	M1Power              : MC_Power;
	M2Power              : MC_Power;

	//Reset	
	MasterReset : MC_Reset;
	M1Reset     : MC_Reset;
	M2Reset     : MC_Reset;

	// PTP
	MasterMoveAbs : MC_MoveAbsolute := (Acceleration := 15000.0, Deceleration := 15000.0, Jerk := 30000);
	MasterSetPos  : MC_SetPosition;
	M1MoveAbs     : MC_MoveAbsolute;
	M2MoveAbs     : MC_MoveAbsolute;

	// Camming
	CamInM1  : MC_CamIn;
	CamOutM1 : MC_CamOut;

	CamInM2  : MC_CamIn;
	CamOutM2 : MC_CamOut;
	
	//Collision Avoidnace
	AddM1ToCAGroup	:MC_AddAxisToGroup;
	AddM2ToCAGroup	:MC_AddAxisToGroup;
	
	GroupEnable		:MC_GroupEnable;
	
	SelecteMoverCAMove	:MC_MoveAbsoluteCA;
	
	
	//IO
	Button     AT %I* : BOOL;
	GreenLight AT %Q* : BOOL;
	RedLight   AT %Q* : BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[M_UserInput();

M_Power();

CASE Step OF
	E_Step.Init:
		IF M_Init() THEN
			Step := E_Step.Idel;
		END_IF

	E_Step.Idel:
		IF rtStart.Q THEN
			MasterPower.Enable := TRUE;
			M1Power.Enable     := TRUE;
			M2Power.Enable     := TRUE;
			Step               := E_Step.Enable;
		END_IF

	E_Step.Enable:
		IF NOT OneOrMoreAxisInError THEN
			IF AllAxisEnabled THEN
				CASE Mode OF
					E_Mode.Auto:
						Step := E_Step.MoveMoverstoSafePos;
					E_Mode.ExternalSetPoint:
						Step := E_Step.AddAxisToCA;
				END_CASE
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.MoveMoverstoSafePos:
		M1MoveAbs(Axis := Mover1,
			Execute    := TRUE,
			Position   := 60.0,
			Velocity   := 200.0);

		M2MoveAbs(Axis := Mover2,
			Execute    := TRUE,
			Position   := 440.0,
			Velocity   := 200.0);

		IF NOT M1MoveAbs.Error AND NOT M2MoveAbs.Error THEN
			IF M1MoveAbs.Done AND M2MoveAbs.Done THEN
				M1MoveAbs(Axis := Mover1, Execute := FALSE);
				M2MoveAbs(Axis := Mover2, Execute := FALSE);
				Step := E_Step.MoveMoversToStartPos;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.MoveMoversToStartPos:
		M1MoveAbs(Axis := Mover1,
			Execute    := TRUE,
			Position   := 101.1,
			Velocity   := 200.0);

		M2MoveAbs(Axis := Mover2,
			Execute    := TRUE,
			Position   := 190.0,
			Velocity   := 200.0);

		IF NOT M1MoveAbs.Error AND NOT M2MoveAbs.Error THEN
			IF M1MoveAbs.Done AND M2MoveAbs.Done THEN
				M1MoveAbs(Axis := Mover1, Execute := FALSE);
				M2MoveAbs(Axis := Mover2, Execute := FALSE);
				Step := E_Step.SetMasterPos;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.SetMasterPos:
		MasterSetPos(Axis := Master,
			Execute       := TRUE,
			Position      := 0.0,
			Mode          := FALSE);

		IF NOT MasterSetPos.Error THEN
			IF MasterSetPos.Done THEN
				MasterSetPos(Axis := Master, Execute := FALSE);
				Step := E_Step.CamIn;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.CamIn:
		CamInM1(Master    := Master,
			Slave         := Mover1,
			Execute       := TRUE,
			MasterOffset  := 0,
			SlaveOffset   := 0,
			MasterScaling := 1,
			SlaveScaling  := 1,
			StartMode     := MC_StartMode.MC_STARTMODE_ABSOLUTE,
			CamTableID    := 1);

		CamInM2(Master    := Master,
			Slave         := Mover2,
			Execute       := TRUE,
			MasterOffset  := 0,
			SlaveOffset   := 0,
			MasterScaling := 1,
			SlaveScaling  := 1,
			StartMode     := MC_StartMode.MC_STARTMODE_ABSOLUTE,
			CamTableID    := 2);

		IF NOT CamInM1.Error AND NOT CamInM2.Error THEN
			IF CamInM1.InSync AND CamInM2.InSync THEN
				CamInM1(Master := Master, Slave := Mover1, Execute := FALSE);
				CamInM2(Master := Master, Slave := Mover2, Execute := FALSE);
				Step := E_Step.MoveMasterToEndOfCam;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.MoveMasterToEndOfCam:
		MasterMoveAbs(Axis := Master,
			Execute        := TRUE,
			Position       := 20000.0,
			Velocity       := VelocityCycle[Cycle]);

		IF rtStop.Q THEN
			Step := E_Step.StoppingMaster;
		END_IF

		IF NOT MasterMoveAbs.Error THEN
			IF MasterMoveAbs.Done THEN
				MasterMoveAbs(Axis := Master, Execute := FALSE);
				Step := E_Step.MoveMasterToStartOfCam;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.MoveMasterToStartOfCam:
		MasterMoveAbs(Axis := Master,
			Execute        := TRUE,
			Position       := 0.0,
			Velocity       := VelocityCycle[Cycle]);

		IF rtStop.Q THEN
			Step := E_Step.StoppingMaster;
		END_IF

		IF NOT MasterMoveAbs.Error THEN
			IF MasterMoveAbs.Done THEN
				MasterMoveAbs(Axis := Master, Execute := FALSE);
				Step := E_Step.MoveMasterToEndOfCam;

				IF Cycle = 3 THEN
					Cycle := 0;
				ELSE
					Cycle := Cycle + 1;
				END_IF
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.StoppingMaster:
		MasterMoveAbs(Axis := Master, Execute := FALSE);
		MasterHault(Axis := Master,
			Execute      := TRUE);

		IF NOT MasterHault.Error THEN
			IF MasterHault.Done THEN
				MasterHault(Axis := Master, Execute := FALSE);
				Step := E_Step.CamOut;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.CamOut:
		CamOutM1(Slave := Mover1, Execute := TRUE);
		CamOutM2(Slave := Mover2, Execute := TRUE);

		IF NOT CamOutM1.Error AND NOT CamOutM2.Error THEN
			IF CamOutM1.Done AND CamOutM2.Done THEN
				CamOutM1(Slave := Mover1, Execute := FALSE);
				CamOutM2(Slave := Mover2, Execute := FALSE);
				Step := E_Step.Disable;
			END_IF
		ELSE
			CamOutM1(Slave := Mover1, Execute := FALSE);
			CamOutM2(Slave := Mover2, Execute := FALSE);
			Step := E_Step.Error;
		END_IF
		
	E_Step.AddAxisToCA:
		AddM1ToCAGroup(
			AxesGroup:=CAGroup , 
			Axis:=Mover1 , 
			Execute:=TRUE , 
			IdentInGroup:=UDINT_TO_IDENTINGROUP(id:=Mover1.NcToPlc.AxisId ) );	
			
		AddM2ToCAGroup(
			AxesGroup:=CAGroup , 
			Axis:=Mover2 , 
			Execute:=TRUE , 
			IdentInGroup:=UDINT_TO_IDENTINGROUP(id:=Mover2.NcToPlc.AxisId ));
			
		IF NOT AddM1ToCAGroup.Error AND NOT AddM2ToCAGroup.Error THEN
			IF AddM1ToCAGroup.Done AND AddM2ToCAGroup.Done THEN
				AddM1ToCAGroup(AxesGroup:=CAGroup , Axis:=Mover1 , Execute:=FALSE ); 
				AddM2ToCAGroup(AxesGroup:=CAGroup , Axis:=Mover2 , Execute:=FALSE ); 
				Step:=E_Step.EnableCA;
			END_IF
		ELSE
			Step:=E_Step.Error;
		END_IF
	
	E_Step.EnableCA:
		GroupEnable(
			AxesGroup:=CAGroup , 
			Execute:=TRUE);		
			
		IF NOT GroupEnable.Error THEN
			IF GroupEnable.Done THEN
				GroupEnable(AxesGroup:=CAGroup , Execute:=FALSE);		
				Step:=E_Step.MoveSelectedMover;
			END_IF
		ELSE
			Step:=E_Step.Error;
		END_IF
		
	E_Step.MoveSelectedMover:
	
		IF NumberOfMoversSelected >0 THEN
			IF SelectedMovers[0].MoverIndex=0 THEN
				SelectedAxis REF=Mover1;
			ELSIF SelectedMovers[0].MoverIndex=1 THEN
				SelectedAxis REF=Mover2;
			ELSE
				SelectedAxis REF=NullAxis;
			END_IF
		ELSE
			SelectedAxis REF=NullAxis;
		END_IF
		
		//Does not respect soft limits.
		//Need to Min/Max the input
		
		DebounceTouch(IN:=NumTouches>0 );
		SelecteMoverCAMove(
			Axis:=SelectedAxis , 
			Execute:=DebounceTouch.Q , 
			ContinuousUpdate:=FALSE , 
			Position:=SingleFingerXPos , 
			Velocity:=500.0 , 
			BufferMode:=MC_BUFFER_MODE.mcAborting, 
			Direction:=Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionNonModulo );	
		
	
	E_Step.Disable:
		MasterPower.Enable := FALSE;
		M1Power.Enable     := FALSE;
		M2Power.Enable     := FALSE;

		IF NOT OneOrMoreAxisInError THEN
			IF AllAxisDisabled THEN
				Step := E_Step.Idel;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.Error:
		IF rtReset.Q THEN
			Step := E_Step.Reset;
		END_IF

	E_Step.Reset:
		M_Reset();

		IF NOT OneOrMoreAxisInError THEN
			Step := E_Step.Init;
		END_IF
END_CASE

M_Status();
]]></ST>
    </Implementation>
    <Method Name="M_Init" Id="{257208cf-25b2-41df-bdd8-38f0ee217f4b}">
      <Declaration><![CDATA[METHOD M_Init : BOOL
VAR_INPUT
END_VAR
VAR_INST
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Start          := FALSE;
StartPremisive := FALSE;
Stop           := FALSE;
StopPremisive  := FALSE;
Reset          := FALSE;
ResetPremisive := FALSE;

MasterMoveAbs(Axis := Master, Execute := FALSE);
M1MoveAbs(Axis := Mover1, Execute := FALSE);
M2MoveAbs(Axis := Mover2, Execute := FALSE);

MasterReset(Axis := Master, Execute := FALSE);
M1Reset(Axis := Mover1, Execute := FALSE);
M2Reset(Axis := Mover2, Execute := FALSE);

MasterSetPos(Axis := Master, Execute := FALSE);

MasterHault(Axis := Master, Execute := FALSE);

CamInM1(Master := Master, Slave := Mover1, Execute := FALSE);
CamInM2(Master := Master, Slave := Mover2, Execute := FALSE);

CamOutM1(Slave := Mover1, Execute := FALSE);
CamOutM2(Slave := Mover2, Execute := FALSE);

IF Mover1.Status.Coupled THEN
	CamOutM1(Slave := Mover1, Execute := TRUE);
	RETURN;
ELSE
	CamOutM1(Slave := Mover1, Execute := FALSE);
END_IF

IF Mover2.Status.Coupled THEN
	CamOutM2(Slave := Mover2, Execute := TRUE);
	RETURN;
ELSE
	CamOutM2(Slave := Mover2, Execute := FALSE);
END_IF

M_Init := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Power" Id="{a91e7a0f-58b4-492c-be4e-09cdeda747a4}">
      <Declaration><![CDATA[METHOD M_Power
VAR_INPUT
END_VAR
VAR_INST
	OverRide : LREAL := 100.0;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MasterPower(Axis    := Master,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := OverRide);

M1Power(Axis        := Mover1,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := 100.0);

M2Power(Axis        := Mover2,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := 100.0);

AllAxisEnabled := MasterPower.Status AND M1Power.Status AND M2Power.Status;

AllAxisDisabled := NOT MasterPower.Status AND NOT M1Power.Status AND NOT M2Power.Status;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{04eb2a0c-37f6-4e2b-9118-ec951a876663}">
      <Declaration><![CDATA[METHOD M_Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MasterReset(Axis := Master,
	Execute      := Master.Status.Error);

M1Reset(Axis := Mover1,
	Execute  := Mover1.Status.Error);

M2Reset(Axis := Mover2,
	Execute  := Mover2.Status.Error);
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Status" Id="{6d5d68e8-78bd-4242-bd9d-cb4c5e329f39}">
      <Declaration><![CDATA[METHOD M_Status
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Master.ReadStatus();
Mover1.ReadStatus();
Mover2.ReadStatus();

OneOrMoreAxisInError := Master.Status.Error OR Mover1.Status.Error OR Mover2.Status.Error;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UserInput" Id="{c3087039-f600-4463-a24a-4a070ff6bad0}">
      <Declaration><![CDATA[METHOD M_UserInput
VAR_INPUT
END_VAR
VAR_INST
	tonButtonDebounce : TON;
	rtButton          : R_TRIG;
	Blink             : BLINK;

	//Converts the XTS viewer mover selection into a PLC array.
	//HMI sends a varrying array size of "tchmi_framework_definitions_XtsMoverListItem"
	fbJson             : FB_JsonDomParser;
	jsonDoc            : SJsonValue;
	fbJsonDataType     : FB_JsonReadWriteDatatype;
	sSelectedMovers    : STRING(1000); //Bound to by the HMI XtsView control -> Selected mover list
	sSelectedMoversOld : STRING(1000);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[tonButtonDebounce(IN := Button, PT := T#100MS);
rtButton(CLK := tonButtonDebounce.Q);

//Set back to auto mode, if using the physical button
IF rtButton.Q THEN
	Mode := E_Mode.Auto;
END_IF

rtStart(CLK := Start OR (rtButton.Q AND Step = E_Step.Idel) OR UsbPbStart);
rtStop(CLK := Stop OR (rtButton.Q AND Step = E_Step.MoveMasterToEndOfCam) OR (rtButton.Q AND Step = E_Step.MoveMasterToStartOfCam) OR UsbPbStop);
rtReset(CLK := Reset OR (rtButton.Q AND Step = E_Step.Error) OR UsbPbReset);

CASE Step OF
	E_Step.Idel:
		StartPremisive := TRUE;
		StopPremisive  := FALSE;
		ResetPremisive := FALSE;
		RedLight       := FALSE;
		Blink(ENABLE := TRUE, TIMELOW := T#0.5S, TIMEHIGH := T#0.5S, OUT => GreenLight);
	E_step.MoveMasterToEndOfCam..E_Step.MoveMasterToStartOfCam:
		StartPremisive := FALSE;
		StopPremisive  := TRUE;
		ResetPremisive := FALSE;
		GreenLight     := TRUE;
		RedLight       := FALSE;
	E_step.Error:
		GreenLight     := FALSE;
		ResetPremisive := TRUE;
		StopPremisive  := FALSE;
		StartPremisive := FALSE;
		Blink(ENABLE := TRUE, TIMELOW := T#0.5S, TIMEHIGH := T#0.5S, OUT => RedLight);
ELSE
	GreenLight     := FALSE;
	RedLight       := FALSE;
	StopPremisive  := FALSE;
	StartPremisive := FALSE;
	ResetPremisive := FALSE;
END_CASE

//Mover selection
IF sSelectedMoversOld <> sSelectedMovers THEN

	//Get Number of selected movers
	jsonDoc                := fbJson.ParseDocument(sSelectedMovers);
	NumberOfMoversSelected := fbJson.GetArraySize(jsonDoc);

	//Update the array of selected movers
	MEMSET(destAddr := ADR(SelectedMovers), fillByte := 0, n := SIZEOF(SelectedMovers));
	fbJsonDataType.SetSymbolFromJson(sSelectedMovers, 'tchmi_framework_definitions_XtsMoverList', SIZEOF(SelectedMovers), ADR(SelectedMovers));
	sSelectedMoversOld := sSelectedMovers;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Demo">
      <LineId Id="2714" Count="192" />
      <LineId Id="3013" Count="1" />
      <LineId Id="3019" Count="4" />
      <LineId Id="3038" Count="0" />
      <LineId Id="3030" Count="4" />
      <LineId Id="3039" Count="1" />
      <LineId Id="3043" Count="0" />
      <LineId Id="3052" Count="0" />
      <LineId Id="3049" Count="0" />
      <LineId Id="3053" Count="0" />
      <LineId Id="3046" Count="2" />
      <LineId Id="3044" Count="0" />
      <LineId Id="3041" Count="0" />
      <LineId Id="3056" Count="0" />
      <LineId Id="3058" Count="2" />
      <LineId Id="3064" Count="2" />
      <LineId Id="3073" Count="0" />
      <LineId Id="3068" Count="3" />
      <LineId Id="3067" Count="0" />
      <LineId Id="3077" Count="0" />
      <LineId Id="3042" Count="0" />
      <LineId Id="3100" Count="2" />
      <LineId Id="3104" Count="0" />
      <LineId Id="3106" Count="1" />
      <LineId Id="3109" Count="1" />
      <LineId Id="3105" Count="0" />
      <LineId Id="3116" Count="0" />
      <LineId Id="3114" Count="0" />
      <LineId Id="3103" Count="0" />
      <LineId Id="3119" Count="2" />
      <LineId Id="3118" Count="0" />
      <LineId Id="3099" Count="0" />
      <LineId Id="3081" Count="5" />
      <LineId Id="3091" Count="1" />
      <LineId Id="3080" Count="0" />
      <LineId Id="3075" Count="0" />
      <LineId Id="2908" Count="26" />
      <LineId Id="99" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Init">
      <LineId Id="474" Count="38" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Power">
      <LineId Id="411" Count="17" />
      <LineId Id="75" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Reset">
      <LineId Id="168" Count="7" />
      <LineId Id="13" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Status">
      <LineId Id="143" Count="4" />
      <LineId Id="22" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_UserInput">
      <LineId Id="373" Count="1" />
      <LineId Id="379" Count="48" />
      <LineId Id="97" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>