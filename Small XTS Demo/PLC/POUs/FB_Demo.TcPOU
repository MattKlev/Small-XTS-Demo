<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_Demo" Id="{885b8ba9-974c-4397-956d-318c5f707ab4}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Demo
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	CAGroup : AXES_GROUP_REF;
	Master  : AXIS_REF;
	Mover1  : AXIS_REF;
	Mover2  : AXIS_REF;
	{attribute 'hide'}
	SelectedAxis : REFERENCE TO AXIS_REF;
	{attribute 'hide'}
	NullAxis : AXIS_REF;

	//Logic vars
	Step  : E_Step;
	Cycle : UINT;

	//User input
	Mode                  : E_Mode := E_Mode.Auto;
	Start                 : BOOL;
	StartPremisive AT %Q* : BOOL;
	Stop                  : BOOL;
	StopPremisive AT %Q*  : BOOL;
	Reset                 : BOOL;
	ResetPremisive AT %Q* : BOOL;

	UsbPbStart AT %I* : BOOL;
	UsbPbStop  AT %I* : BOOL;
	UsbPbReset AT %I* : BOOL;

	rtStart : R_TRIG;
	rtStop  : R_TRIG;
	rtReset : R_TRIG;

	VelocityCycle : ARRAY[0..3] OF LREAL := [1250.0, 1000.0, 750.0, 500.0];

	NumTouches       : UDINT;
	DebounceTouch    : TON := (PT := T#100MS);
	SingleFingerXPos : LREAL;

	NumberOfMoversSelected : UDINT;
	SelectedMovers         : tchmi_framework_definitions_XtsMoverList;

	//Power
	AllAxisEnabled       : BOOL;
	AllAxisDisabled      : BOOL;
	OneOrMoreAxisInError : BOOL;
	MasterPower          : MC_Power;
	MasterHault          : MC_Halt;
	M1Power              : MC_Power;
	M2Power              : MC_Power;

	//Reset	
	MasterReset : MC_Reset;
	M1Reset     : MC_Reset;
	M2Reset     : MC_Reset;

	// PTP
	MasterMoveAbs : MC_MoveAbsolute := (Acceleration := 15000.0, Deceleration := 15000.0, Jerk := 30000);
	MasterSetPos  : MC_SetPosition;
	M1MoveAbs     : MC_MoveAbsolute;
	M2MoveAbs     : MC_MoveAbsolute;

	// Camming
	CamInM1  : MC_CamIn;
	CamOutM1 : MC_CamOut;

	CamInM2  : MC_CamIn;
	CamOutM2 : MC_CamOut;

	//Collision Avoidnace
	GroupState     : MC_GroupReadStatus;
	AddM1ToCAGroup : MC_AddAxisToGroup;
	AddM2ToCAGroup : MC_AddAxisToGroup;

	GroupEnable       : MC_GroupEnable;
	GroupReset        : MC_GroupReset;
	GroupDisable      : MC_GroupDisable;
	GroupHalt         : MC_GroupHalt;
	RemoveM1FromGroup : MC_RemoveAxisFromGroup;
	RemoveM2FromGroup : MC_RemoveAxisFromGroup;

	SelecteMoverCAMove : MC_MoveAbsoluteCA;

	//IO
	Button     AT %I* : BOOL;
	GreenLight AT %Q* : BOOL;
	RedLight   AT %Q* : BOOL;
	
	//Iot
	IotStartButton		:BOOL;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[M_UserInput();

M_Power();

CASE Step OF
	E_Step.Init:
		IF M_Init() THEN
			Step := E_Step.Idel;
		END_IF

	E_Step.Idel:
		IF rtStart.Q THEN
			MasterPower.Enable := TRUE;
			M1Power.Enable     := TRUE;
			M2Power.Enable     := TRUE;
			Step               := E_Step.Enable;
		END_IF

		IF GroupState.GroupErrorStop OR OneOrMoreAxisInError THEN
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.Enable:
		IF NOT OneOrMoreAxisInError THEN
			IF AllAxisEnabled THEN
				CASE Mode OF
					E_Mode.Auto:
						Step := E_Step.MoveMoverstoSafePos;
					E_Mode.ExternalSetPoint:
						Step := E_Step.AddAxisToCA;
				END_CASE
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.MoveMoverstoSafePos:
		M1MoveAbs(Axis := Mover1,
			Execute    := TRUE,
			Position   := 60.0,
			Velocity   := 200.0);

		M2MoveAbs(Axis := Mover2,
			Execute    := TRUE,
			Position   := 440.0,
			Velocity   := 200.0);

		IF NOT M1MoveAbs.Error AND NOT M2MoveAbs.Error THEN
			IF M1MoveAbs.Done AND M2MoveAbs.Done THEN
				M1MoveAbs(Axis := Mover1, Execute := FALSE);
				M2MoveAbs(Axis := Mover2, Execute := FALSE);
				Step := E_Step.MoveMoversToStartPos;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.MoveMoversToStartPos:
		M1MoveAbs(Axis := Mover1,
			Execute    := TRUE,
			Position   := 101.1,
			Velocity   := 200.0);

		M2MoveAbs(Axis := Mover2,
			Execute    := TRUE,
			Position   := 190.0,
			Velocity   := 200.0);

		IF NOT M1MoveAbs.Error AND NOT M2MoveAbs.Error THEN
			IF M1MoveAbs.Done AND M2MoveAbs.Done THEN
				M1MoveAbs(Axis := Mover1, Execute := FALSE);
				M2MoveAbs(Axis := Mover2, Execute := FALSE);
				Step := E_Step.SetMasterPos;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.SetMasterPos:
		MasterSetPos(Axis := Master,
			Execute       := TRUE,
			Position      := 0.0,
			Mode          := FALSE);

		IF NOT MasterSetPos.Error THEN
			IF MasterSetPos.Done THEN
				MasterSetPos(Axis := Master, Execute := FALSE);
				Step := E_Step.CamIn;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.CamIn:
		CamInM1(Master    := Master,
			Slave         := Mover1,
			Execute       := TRUE,
			MasterOffset  := 0,
			SlaveOffset   := 0,
			MasterScaling := 1,
			SlaveScaling  := 1,
			StartMode     := MC_StartMode.MC_STARTMODE_ABSOLUTE,
			CamTableID    := 1);

		CamInM2(Master    := Master,
			Slave         := Mover2,
			Execute       := TRUE,
			MasterOffset  := 0,
			SlaveOffset   := 0,
			MasterScaling := 1,
			SlaveScaling  := 1,
			StartMode     := MC_StartMode.MC_STARTMODE_ABSOLUTE,
			CamTableID    := 2);

		IF NOT CamInM1.Error AND NOT CamInM2.Error THEN
			IF CamInM1.InSync AND CamInM2.InSync THEN
				CamInM1(Master := Master, Slave := Mover1, Execute := FALSE);
				CamInM2(Master := Master, Slave := Mover2, Execute := FALSE);
				Step := E_Step.MoveMasterToEndOfCam;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.MoveMasterToEndOfCam:
		MasterMoveAbs(Axis := Master,
			Execute        := TRUE,
			Position       := 20000.0,
			Velocity       := VelocityCycle[Cycle]);

		IF rtStop.Q THEN
			Step := E_Step.StoppingMaster;
		END_IF

		IF NOT MasterMoveAbs.Error THEN
			IF MasterMoveAbs.Done THEN
				MasterMoveAbs(Axis := Master, Execute := FALSE);
				Step := E_Step.MoveMasterToStartOfCam;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.MoveMasterToStartOfCam:
		MasterMoveAbs(Axis := Master,
			Execute        := TRUE,
			Position       := 0.0,
			Velocity       := VelocityCycle[Cycle]);

		IF rtStop.Q THEN
			Step := E_Step.StoppingMaster;
		END_IF

		IF NOT MasterMoveAbs.Error THEN
			IF MasterMoveAbs.Done THEN
				MasterMoveAbs(Axis := Master, Execute := FALSE);
				Step := E_Step.MoveMasterToEndOfCam;

				IF Cycle = 3 THEN
					Cycle := 0;
				ELSE
					Cycle := Cycle + 1;
				END_IF
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.StoppingMaster:
		MasterMoveAbs(Axis := Master, Execute := FALSE);
		MasterHault(Axis := Master,
			Execute      := TRUE);

		IF NOT MasterHault.Error THEN
			IF MasterHault.Done THEN
				MasterHault(Axis := Master, Execute := FALSE);
				Step := E_Step.CamOut;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.CamOut:
		CamOutM1(Slave := Mover1, Execute := TRUE);
		CamOutM2(Slave := Mover2, Execute := TRUE);

		IF NOT CamOutM1.Error AND NOT CamOutM2.Error THEN
			IF CamOutM1.Done AND CamOutM2.Done THEN
				CamOutM1(Slave := Mover1, Execute := FALSE);
				CamOutM2(Slave := Mover2, Execute := FALSE);
				Step := E_Step.Disable;
			END_IF
		ELSE
			CamOutM1(Slave := Mover1, Execute := FALSE);
			CamOutM2(Slave := Mover2, Execute := FALSE);
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.AddAxisToCA:
		AddM1ToCAGroup(AxesGroup := CAGroup,
			Axis                 := Mover1,
			Execute              := TRUE,
			IdentInGroup         := UDINT_TO_IDENTINGROUP(id := Mover1.NcToPlc.AxisId));

		AddM2ToCAGroup(AxesGroup := CAGroup,
			Axis                 := Mover2,
			Execute              := TRUE,
			IdentInGroup         := UDINT_TO_IDENTINGROUP(id := Mover2.NcToPlc.AxisId));

		IF NOT AddM1ToCAGroup.Error AND NOT AddM2ToCAGroup.Error THEN
			IF AddM1ToCAGroup.Done AND AddM2ToCAGroup.Done THEN
				AddM1ToCAGroup(AxesGroup := CAGroup, Axis := Mover1, Execute := FALSE);
				AddM2ToCAGroup(AxesGroup := CAGroup, Axis := Mover2, Execute := FALSE);
				Step := E_Step.EnableCA;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.EnableCA:
		GroupEnable(AxesGroup := CAGroup,
			Execute           := TRUE);

		IF NOT GroupEnable.Error THEN
			IF GroupEnable.Done THEN
				GroupEnable(AxesGroup := CAGroup, Execute := FALSE);
				Step := E_Step.MoveSelectedMover;
			END_IF
		ELSE
			Step := E_Step.Error;
		END_IF

	E_Step.MoveSelectedMover:
		IF NumberOfMoversSelected > 0 THEN
			IF SelectedMovers[0].MoverIndex = 0 THEN
				SelectedAxis REF= Mover1;
			ELSIF SelectedMovers[0].MoverIndex = 1 THEN
				SelectedAxis REF= Mover2;
			ELSE
				SelectedAxis REF= NullAxis;
			END_IF
		ELSE
			SelectedAxis REF= NullAxis;
		END_IF

		//Does not respect soft limits.
		//Need to Min/Max the input

		DebounceTouch(IN := NumTouches > 0 AND (SelecteMoverCAMove.Position <> SingleFingerXPos));

		IF DebounceTouch.Q THEN
			IF SingleFingerXPos < 42.0 THEN
				SelecteMoverCAMove.Position := 42.0;
			ELSIF SingleFingerXPos > 460.0 THEN
				SelecteMoverCAMove.Position := 460.0;
			ELSE
				SelecteMoverCAMove.Position := SingleFingerXPos;
			END_IF
		END_IF

		SelecteMoverCAMove(Axis := SelectedAxis,
			Execute             := DebounceTouch.Q,
			ContinuousUpdate    := FALSE,
			Velocity            := 500.0,
			BufferMode          := MC_BUFFER_MODE.mcAborting,
			Direction           := Tc3_Mc3Definitions.MC_DIRECTION.mcDirectionNonModulo);

		IF rtStop.Q THEN
			Step := E_Step.HaltMovers;
		END_IF

		IF GroupState.GroupErrorStop THEN
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.HaltMovers:
		GroupHalt(AxesGroup := CAGroup, Execute := TRUE);

		IF NOT GroupHalt.Error THEN
			IF GroupHalt.Done THEN
				GroupHalt(AxesGroup := CAGroup, Execute := FALSE);
				Step := E_Step.DisableCA;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.DisableCA:
		GroupDisable(AxesGroup := CAGroup, Execute := TRUE);

		IF NOT GroupDisable.Error THEN
			IF GroupDisable.Done THEN
				GroupDisable(AxesGroup := CAGroup, Execute := FALSE);
				Step := E_Step.RemoveAxisFromCA;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.RemoveAxisFromCA:
		RemoveM1FromGroup(AxesGroup := CAGroup,
			Execute                 := TRUE,
			IdentInGroup            := UDINT_TO_IDENTINGROUP(Mover1.NcToPlc.AxisId));

		RemoveM2FromGroup(AxesGroup := CAGroup,
			Execute                 := TRUE,
			IdentInGroup            := UDINT_TO_IDENTINGROUP(Mover2.NcToPlc.AxisId));

		IF NOT RemoveM1FromGroup.Error AND NOT RemoveM2FromGroup.Error THEN
			IF RemoveM1FromGroup.Done AND RemoveM2FromGroup.Done THEN
				RemoveM1FromGroup(AxesGroup := CAGroup, Execute := FALSE);
				RemoveM2FromGroup(AxesGroup := CAGroup, Execute := FALSE);
				Step := E_Step.Disable;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.Disable:
		MasterPower(Axis := Master, Enable := FALSE);
		M1Power(Axis := Mover1, Enable := FALSE);
		M2Power(Axis := Mover2, Enable := FALSE);

		M_Status();

		//Needs work this will not go into error state directly if power is removed and the axis is busy for some reason.
		IF NOT OneOrMoreAxisInError THEN
			IF AllAxisDisabled THEN
				Step := E_Step.Idel;
			END_IF
		ELSE
			LogStepAndGoToErrorState(Step);
		END_IF

	E_Step.Error:
		IF rtReset.Q THEN
			Step := E_Step.Reset;
		END_IF

	E_Step.Reset:
		M_Reset();

		IF NOT OneOrMoreAxisInError AND NOT GroupState.GroupErrorStop THEN
			Step := E_Step.Init;
		END_IF
END_CASE

M_Status();


IoT();]]></ST>
    </Implementation>
    <Method Name="IoT" Id="{0dd06caf-0599-4034-bd2a-8eb76b49595b}">
      <Declaration><![CDATA[METHOD IoT
VAR_INPUT
END_VAR
VAR_INST
	fbIoT : FB_IotCommunicator := (
    sHostName := '68.183.154.213', // MQTT Broker Adress
	bRetain    :=FALSE,
    nPort := 1883,                   // MQTT Port
    sMainTopic := 'XTSDemo',          // Main Topic
    sDeviceName := 'Demo Stand 1',  // Device Name
    sUser := 'SmallXTSDemo',            // MQTT Username
    sPassword := '');         // MQTT Password

	stData: ST_IoTData;              // Values to send
	timer : TON;                         // Timer to send data
	
END_VAR
VAR
	nDoubleCounter: INT;
	SendMsg: BOOL;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[fbIoT.Execute(TRUE);


timer(IN := NOT timer.Q, PT := T#100MS);

IF fbIoT.bConnected AND timer.Q THEN
	stData.StartButton:=IotStartButton;
	stData.Mover1ActPos:=Mover1.NcToPlc.ActPos;
	stData.Mover2ActPos:=Mover2.NcToPlc.ActPos;
    fbIoT.SendData(ADR(stData), SIZEOF(stData));
END_IF


IF fbIoT.fbCommand.bAvailable THEN
    IF fbIoT.fbCommand.sVarName = 'StartButton' THEN
        fbIoT.fbCommand.GetValue(ADR(stData.StartButton), SIZEOF(stData.StartButton), E_IotCommunicatorDatatype.type_BOOL);
		IotStartButton:=stData.StartButton;
    END_IF
    fbIoT.fbCommand.Remove();
END_IF

IF SendMsg THEN
	fbIoT.SendMessage('This is a test alarm message!');
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Init" Id="{257208cf-25b2-41df-bdd8-38f0ee217f4b}">
      <Declaration><![CDATA[METHOD M_Init : BOOL
VAR_INPUT
END_VAR
VAR_INST
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[Start          := FALSE;
StartPremisive := FALSE;
Stop           := FALSE;
StopPremisive  := FALSE;
Reset          := FALSE;
ResetPremisive := FALSE;

AddM1ToCAGroup(AxesGroup := CAGroup, Axis := Mover1, Execute := FALSE);
AddM2ToCAGroup(AxesGroup := CAGroup, Axis := Mover2, Execute := FALSE);

GroupEnable(AxesGroup := CAGroup, Execute := FALSE);
GroupReset(AxesGroup := CAGroup, Execute := FALSE);
GroupDisable(AxesGroup := CAGroup, Execute := FALSE);
GroupHalt(AxesGroup := CAGroup, Execute := FALSE);

RemoveM1FromGroup(AxesGroup := CAGroup, Execute := FALSE);
RemoveM2FromGroup(AxesGroup := CAGroup, Execute := FALSE);

SelecteMoverCAMove(Axis := SelectedAxis, Execute := FALSE);

MasterMoveAbs(Axis := Master, Execute := FALSE);
M1MoveAbs(Axis := Mover1, Execute := FALSE);
M2MoveAbs(Axis := Mover2, Execute := FALSE);

MasterReset(Axis := Master, Execute := FALSE);
M1Reset(Axis := Mover1, Execute := FALSE);
M2Reset(Axis := Mover2, Execute := FALSE);

MasterSetPos(Axis := Master, Execute := FALSE);

MasterHault(Axis := Master, Execute := FALSE);

CamInM1(Master := Master, Slave := Mover1, Execute := FALSE);
CamInM2(Master := Master, Slave := Mover2, Execute := FALSE);

CamOutM1(Slave := Mover1, Execute := FALSE);
CamOutM2(Slave := Mover2, Execute := FALSE);

IF Mover1.Status.Coupled THEN
	CamOutM1(Slave := Mover1, Execute := TRUE);
	RETURN;
ELSE
	CamOutM1(Slave := Mover1, Execute := FALSE);
END_IF

IF Mover2.Status.Coupled THEN
	CamOutM2(Slave := Mover2, Execute := TRUE);
	RETURN;
ELSE
	CamOutM2(Slave := Mover2, Execute := FALSE);
END_IF

M_Init := TRUE;]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Power" Id="{a91e7a0f-58b4-492c-be4e-09cdeda747a4}">
      <Declaration><![CDATA[METHOD M_Power
VAR_INPUT
END_VAR
VAR_INST
	OverRide : LREAL := 100.0;

END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MasterPower(Axis    := Master,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := OverRide);

M1Power(Axis        := Mover1,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := 100.0);

M2Power(Axis        := Mover2,
	Enable_Positive := TRUE,
	Enable_Negative := TRUE,
	Override        := 100.0);

AllAxisEnabled := MasterPower.Status AND M1Power.Status AND M2Power.Status;

AllAxisDisabled := NOT MasterPower.Status AND NOT M1Power.Status AND NOT M2Power.Status;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{04eb2a0c-37f6-4e2b-9118-ec951a876663}">
      <Declaration><![CDATA[METHOD M_Reset : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[MasterReset(Axis := Master, Execute := Master.Status.Error);

IF NOT MasterReset.Busy THEN
	MasterReset(Axis := Master, Execute := FALSE);
END_IF

M1Reset(Axis := Mover1, Execute := Mover1.Status.Error);

IF NOT M1Reset.Busy THEN
	M1Reset(Axis := Mover1, Execute := FALSE);
END_IF

M2Reset(Axis := Mover2, Execute := Mover2.Status.Error);

IF NOT M2Reset.Busy THEN
	M2Reset(Axis := Mover2, Execute := FALSE);
END_IF

GroupReset(AxesGroup := CAGroup, Execute := GroupState.GroupErrorStop);

IF NOT GroupReset.Busy THEN
	GroupReset(AxesGroup := CAGroup, Execute := FALSE);
END_IF]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Status" Id="{6d5d68e8-78bd-4242-bd9d-cb4c5e329f39}">
      <Declaration><![CDATA[METHOD M_Status
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[Master.ReadStatus();
Mover1.ReadStatus();
Mover2.ReadStatus();

OneOrMoreAxisInError := Master.Status.Error OR Mover1.Status.Error OR Mover2.Status.Error;

GroupState(AxesGroup := CAGroup,
	Enable           := TRUE,
	Valid            =>,
	Busy             =>,
	GroupMoving      =>,
	GroupHoming      =>,
	GroupErrorStop   =>,
	GroupNotReady    =>,
	GroupStandby     =>,
	GroupStopping    =>,
	GroupDisabled    =>,
	AllAxesStanding  =>,
	ConstantVelocity =>,
	Accelerating     =>,
	Decelerating     =>,
	InPosition       =>);]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UserInput" Id="{c3087039-f600-4463-a24a-4a070ff6bad0}">
      <Declaration><![CDATA[METHOD M_UserInput
VAR_INPUT
END_VAR
VAR_INST
	tonButtonDebounce : TON;
	rtButton          : R_TRIG;
	Blink             : BLINK;

	//Converts the XTS viewer mover selection into a PLC array.
	//HMI sends a varrying array size of "tchmi_framework_definitions_XtsMoverListItem"
	fbJson             : FB_JsonDomParser;
	jsonDoc            : SJsonValue;
	fbJsonDataType     : FB_JsonReadWriteDatatype;
	sSelectedMovers    : STRING(1000); //Bound to by the HMI XtsView control -> Selected mover list
	sSelectedMoversOld : STRING(1000);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[tonButtonDebounce(IN := Button OR IotStartButton, PT := T#100MS);
rtButton(CLK := tonButtonDebounce.Q);

//Set back to auto mode, if using the physical button
IF rtButton.Q THEN
	Mode := E_Mode.Auto;
END_IF

rtStart(CLK := Start OR (rtButton.Q AND Step = E_Step.Idel) OR UsbPbStart);
rtStop(CLK := Stop OR (rtButton.Q AND Step = E_Step.MoveMasterToEndOfCam) OR (rtButton.Q AND Step = E_Step.MoveMasterToStartOfCam) OR UsbPbStop);
rtReset(CLK := Reset OR (rtButton.Q AND Step = E_Step.Error) OR UsbPbReset);

CASE Step OF
	E_Step.Idel:
		StartPremisive := TRUE;
		StopPremisive  := FALSE;
		ResetPremisive := FALSE;
		RedLight       := FALSE;
		Blink(ENABLE := TRUE, TIMELOW := T#0.5S, TIMEHIGH := T#0.5S, OUT => GreenLight);
	E_step.MoveMasterToEndOfCam, E_Step.MoveMasterToStartOfCam, E_Step.MoveSelectedMover:
		StartPremisive := FALSE;
		StopPremisive  := TRUE;
		ResetPremisive := FALSE;
		GreenLight     := TRUE;
		RedLight       := FALSE;
	E_step.Error:
		GreenLight     := FALSE;
		ResetPremisive := TRUE;
		StopPremisive  := FALSE;
		StartPremisive := FALSE;
		Blink(ENABLE := TRUE, TIMELOW := T#0.5S, TIMEHIGH := T#0.5S, OUT => RedLight);
ELSE
	GreenLight     := FALSE;
	RedLight       := FALSE;
	StopPremisive  := FALSE;
	StartPremisive := FALSE;
	ResetPremisive := FALSE;
END_CASE

//Mover selection
IF sSelectedMoversOld <> sSelectedMovers THEN

	//Get Number of selected movers
	jsonDoc                := fbJson.ParseDocument(sSelectedMovers);
	NumberOfMoversSelected := fbJson.GetArraySize(jsonDoc);

	//Update the array of selected movers
	MEMSET(destAddr := ADR(SelectedMovers), fillByte := 0, n := SIZEOF(SelectedMovers));
	fbJsonDataType.SetSymbolFromJson(sSelectedMovers, 'tchmi_framework_definitions_XtsMoverList', SIZEOF(SelectedMovers), ADR(SelectedMovers));
	sSelectedMoversOld := sSelectedMovers;
END_IF
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_Demo">
      <LineId Id="3472" Count="347" />
      <LineId Id="3911" Count="1" />
      <LineId Id="99" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.IoT">
      <LineId Id="5" Count="0" />
      <LineId Id="18" Count="4" />
      <LineId Id="45" Count="0" />
      <LineId Id="42" Count="1" />
      <LineId Id="23" Count="0" />
      <LineId Id="17" Count="0" />
      <LineId Id="25" Count="4" />
      <LineId Id="44" Count="0" />
      <LineId Id="32" Count="1" />
      <LineId Id="24" Count="0" />
      <LineId Id="38" Count="0" />
      <LineId Id="37" Count="0" />
      <LineId Id="39" Count="1" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Init">
      <LineId Id="606" Count="51" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Power">
      <LineId Id="461" Count="17" />
      <LineId Id="75" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Reset">
      <LineId Id="227" Count="21" />
      <LineId Id="188" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_Status">
      <LineId Id="172" Count="20" />
      <LineId Id="168" Count="0" />
    </LineIds>
    <LineIds Name="FB_Demo.M_UserInput">
      <LineId Id="575" Count="50" />
      <LineId Id="97" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>